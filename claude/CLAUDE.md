# Global Development Guidelines

## Code Style & Standards

### General Formatting
- Use 2-space indentation for JavaScript/TypeScript/JSON/YAML
- Use 4-space indentation for Rust/C#/.NET
- Line length limit: 100 characters
- Always use trailing commas in multi-line structures
- Prefer explicit types over implicit when it aids readability

### Rust Best Practices
- Use `cargo fmt` for consistent formatting
- Run `cargo clippy` for linting and suggestions
- Enable `#![warn(clippy::all, clippy::pedantic)]` in lib.rs/main.rs
- Use `cargo test` for running tests
- Prefer `Result<T, E>` over panicking
- Use meaningful error types with `thiserror` or `anyhow`
- Document public APIs with `///` comments
- NEVER add `#[allow(dead_code)]` - if new changes aren't used, remove them instead

### .NET Best Practices  
- Use `dotnet format` for code formatting
- Run `dotnet build --verbosity normal` for builds
- Use `dotnet test` for running tests
- Follow C# naming conventions (PascalCase for public, camelCase for private)
- Use nullable reference types (`#nullable enable`)
- Prefer `async/await` over raw Task handling
- Use dependency injection patterns

## Security Guidelines

### Secrets Management
- NEVER commit secrets, API keys, or credentials to repositories
- Use environment variables or secure vaults for sensitive data
- Files matching these patterns are BLOCKED: `.env*`, `*secret*`, `*key*`, `*credentials*`
- Use `.gitignore` to exclude sensitive files

### Code Security
- Validate all user inputs
- Use parameterized queries for database operations  
- Keep dependencies updated and scan for vulnerabilities
- Follow OWASP security guidelines
- Review all external dependencies before adding

## Git Workflow

### Commit Guidelines
- Never add "Generated by AI" to commit messages
- Keep commit descriptions compact: max 3 points for small changes, 5 for medium, 8 for large
- Use conventional commit format: `type(scope): description`
- Always review changes before committing
- Test thoroughly before pushing

### Branch Management
- Create new repository with main branch
- Create feature branches from main/master
- Use descriptive branch names: `feature/user-auth`, `fix/memory-leak`
- Squash commits when merging to keep history clean
- Never force push to shared branches

## Test-Driven Development

### Testing Approach
- Write tests BEFORE implementing features when possible
- Aim for high test coverage (>80%)
- Use descriptive test names that explain the scenario
- Test edge cases and error conditions
- Run tests frequently during development

### Rust Testing
```bash
cargo test                    # Run all tests
cargo test --lib             # Run library tests only
cargo test integration_test  # Run specific test
cargo test -- --nocapture    # Show println! output
```

### .NET Testing
```bash
dotnet test                           # Run all tests
dotnet test --filter "Category=Unit" # Run specific category
dotnet test --logger trx             # Generate test report
dotnet test --collect:"XPlat Code Coverage" # Coverage report
```

## Common Commands

### Build & Development
```bash
# Rust
cargo build                  # Debug build
cargo build --release       # Release build  
cargo run                   # Build and run
cargo check                 # Fast compile check
cargo clippy                # Linting
cargo fmt                   # Format code

# .NET
dotnet build                 # Build solution
dotnet run                   # Build and run
dotnet publish              # Publish for deployment
dotnet restore              # Restore packages
dotnet format               # Format code
dotnet clean                # Clean build artifacts
```

### Package Management
```bash
# Rust
cargo add <package>         # Add dependency
cargo update               # Update dependencies
cargo audit                # Security audit

# .NET  
dotnet add package <name>   # Add NuGet package
dotnet restore             # Restore packages
dotnet list package        # List packages
dotnet outdated            # Check for updates
```

## Development Environment

### Required Tools
- Rust: `rustc`, `cargo`, `clippy`, `rustfmt`
- .NET: `.NET SDK`, `dotnet CLI`
- Git with proper configuration
- Code editor with language support (VS Code, Neovim, etc.)

### Environment Variables
- `RUST_BACKTRACE=1` for detailed error traces
- `CARGO_TERM_COLOR=always` for colored output
- `DOTNET_CLI_TELEMETRY_OPTOUT=1` to disable telemetry

## Performance & Optimization

### Rust Performance
- Use `cargo build --release` for production builds
- Profile with `cargo flamegraph` or `perf`
- Consider `cargo-criterion` for benchmarking
- Avoid unnecessary allocations and clones

### .NET Performance  
- Use `dotnet publish -c Release` for production
- Profile with dotTrace or PerfView
- Consider memory usage patterns
- Use `Span<T>` and `Memory<T>` for high-performance scenarios

## Documentation

### Code Documentation
- Document all public APIs
- Include usage examples in doc comments
- Keep README files updated with setup instructions
- Use inline comments sparingly, prefer self-documenting code

### Project Documentation
- Maintain clear README with setup/build/test instructions
- Document architecture decisions
- Keep changelog updated for releases
- Include troubleshooting guides

## Error Handling

### Rust Error Handling
- Use `Result<T, E>` for recoverable errors
- Use `panic!` only for unrecoverable errors
- Consider `anyhow` for application errors, `thiserror` for library errors
- Provide meaningful error messages

### .NET Error Handling
- Use exceptions for exceptional circumstances only
- Create custom exception types when appropriate
- Always dispose of resources properly (`using` statements)
- Log errors appropriately for debugging

## Automation Reminders

### Pre-commit Checks
- Format code automatically
- Run linters and static analysis
- Execute relevant tests
- Check for secrets or sensitive data
- Validate commit message format

### Quality Gates
- All tests must pass before merging
- Code coverage thresholds must be met
- Static analysis must pass without errors
- Security scans must show no high-severity issues
